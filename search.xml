<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[游戏关卡设计与玩家心理]]></title>
    <url>%2F2017%2F09%2F18%2F%E6%B8%B8%E6%88%8F%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[游戏设计要点 整体结构来说：关卡难度提升遵循“循序渐进”原则，要有意识的将关卡挑战设置为由易到难，让玩家有成就感。在游戏过程中，设计做到“张弛有度”，“张”是指正常的挑战关卡，带给玩家挑战和刺激，“弛”是指游戏让玩家放松，感受不到危险的关卡段落。张弛的比例一般可以控制在2:1。 单关结构：单个关卡前后部分不能设计饱和，可以在关卡开始和结束时留出相对安全的部分让玩家放松。每个关卡应该有明确的主题玩法。 设计技巧：①风险引诱，给玩家在一个挑战前两种选择，一种选择是通过平常的方式解决，另一种采用高风险的方法通过，但提供Bonus。最终目的，可以让菜鸟玩家继续游戏，让高手玩家获得成就感。②关卡可以被记忆，通过记住关卡组成，有准备的通过挑战（非Rougelike）。③高操作反馈比，操作反馈比=游戏表现/玩家付出的操作，通过高操作反馈比的设计，改变玩家心情曲线。 关卡设计流程 概念设计（Concept Collection）： 创意收集，可以是玩法，美术风格，形象，主题，原创，也可以有借鉴，将其他经典或有趣的玩法重新搭配组合形成。 头脑风暴 故事背景 剧情需要：根据所有关卡的难度曲线，定下某种玩法在某关出现。 塑造核心玩法（Building Core Gameplay）：从概念设计中做选择一到两种作为支撑游戏的玩法。比如射击游戏核心玩法是瞄准射击，跑酷游戏的核心玩法是跳跃躲避，RPG核心是升级打怪，赛车游戏的核心玩法是加速过弯。 绘制关卡蓝图（Design Level Layout）：关卡蓝图一般为2D平面图，表现出关卡的平面结构、路线、方位、区段、进程，图中一般包含：图例、路线、区域划分、掩体、其他各类元素（“出生点”，“补给点”），同时说明不同区域的核心玩法，如推进、防守、生存、保卫、boss战。 搭建灰盒模型（Building Gray Box）：重点放在视线、路线、空间、距离、高低、掩体位置等非常具体和客观的方面。 初版制作（First Playable Protocol）：FPP关卡基于灰盒（别名白盒）关卡，并拥有成品级的美术效果及细节。 团队工作并量产（Team Production） 优化打磨（Optimization and Polish） 关卡设计技巧 反馈系统：告诉玩家距离目标还有多远。他通过点数、级别、得分、进度条等形式反映。让玩家认识到：等…的时候，游戏就结束了。对玩家而言，实时反馈是一种承诺，目标可以达到，给人继续玩下去的动力。 风险系统：在关卡中，尽量营造出多种可供选择的路线，并让路线具有风险和回报的差异。越短的路线越危险，越长的路线越安全。高风险获得高回报，低风险低回报。 游戏的电影化：符合大众口味的剧本，有血有肉的人物形象，自然的剧情交代方式，灵活的游戏镜头设计。 基于大众的习惯认知来制作元素的外观，比如将危险部分与火焰，尖刺，悬崖等联系起来。 通过心流曲线把控游戏紧张和释放的节奏。]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学之排列组合]]></title>
    <url>%2F2017%2F09%2F16%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B9%8B%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[基本计数原理加法与乘法原理 加法原理： 集合中的子集是全集的划分，子集互不相交，子集的并集是全集。则全集元素个数为子集元素个数相加。 乘法原理： 为加法原理推广，S为有序对(a,b)集合，其中a有p种选择，b有q种选择，则|s|=pq 。 选择顺序会影响乘法原理的使用。一个任务的完成分为若干子任务，如果某个完成子任务的途径不依赖于已经完成的任务，那么可以用乘法原理，否则不能。 计数方法-一一对应 A与B集合中元素一一对应，A集合计数困难，可以通过对B集合计数来求A集合中元素个数。 Cayley定理：n个有标号的顶点的树的数目等于$n^{n-2}$。证明：1. n个顶点树的数目=序列 $b_{1},b_{2},…b_{n-2}(0&lt;b\leqslant n)$ 的数目 2. 相应序列的数目为 $n^{n-2}$。 排列组合问题 无重排列：从n个不同元素中取r个不重复的元素，按次排列，排列的个数用P(n,r)表示。P(n,r)=n(n-1)(n-2)…(n-r+1) 无重组合：从n个不同元素中取r个不重复的元素组成一个子集（集合元素无顺序），从而不考虑其元素的顺序，组合的个数用C(n,r)或$\binom{n}{r}$。有C(n,r)·r!=P(n,r) 循环排列（圆周排列） 从n个不同的元素中取r个沿一个圆周排列，叫做循环排列，表示为Q(n,r),其中Q(n,r)=P(n,r)/r 。 项链数：经翻转能与原来重合的排列视为同一排列。在圆排列的基础上计算，为圆排列的一半，n取r的项链数为P(n,r)/2r, r满足3≤r≤n。 组合 组合的性质 $\binom{n}{r}=\binom{n}{n-r}$ 例子：第一种情况，假定有6个不同的元素，分成3组，第一组有1个元素，第二组有2个元素，第三组有3个元素，方案共有 $C_{6}^{1}\cdot C_{5}^{2}\cdot C_{3}^{3}$ 种。第二种情况，假定有6个不同的元素，两两分成3组，方案共有 $\frac{C_{6}^{2}\cdot C_{4}^{2}\cdot C_{2}^{2}}{3!}$ 种。由于三个组顺序无关，故需要除以3!。 多重集的排列和组合 集合s中有重复元素的情况，我们称S为一个多重集。如 S={a,a,a,b,c,c,c}={2a,1b,3c}。 无限多重集S的r-排列：设多重集S中有k种不同的元素，每种元素的重复数是无穷的，记为$S={\infty a_{1},\infty a_{2},…,\infty a_{k}}$，则S的r-排列的个数为$k^{r}$（每个位置的选择都有k种）。 有限多重集S的全排列：设多重集S有k种不同的元素，每种元素的重复数有限，记为$S={n_{1}a_{1},n_{2}a_{2},…,n_{k}a_{k}}$，设$n=n_{1}+n_{2}+…n_{k}$，那么S的n-排列或S的全排列个数为$$\binom{n}{n_{1}}\binom{n-n_{1}}{n_{2}}\binom{n-n_{1}-n_{2}}{n_{3}}…\binom{n-n_{1}-n_{2}-…n_{k-1}}{n_{k}}=\frac{n!}{n_{1}!n_{2}!…n_{k}!}$$ 。 无限多重集S的r-组合： 设多重集S中有k种不同的元素，每种元素的重复数是无穷的，记为$S={\infty a_{1},\infty a_{2},…,\infty a_{k}}$， S的r-组合个数为$$\binom{r+k-1}{r}=\binom{r+k-1}{k-1}$$S的r-组合指集合满足$x_{1}+x_{2}+…x_{k}=r$ 的集合${x_{1}a_{1},x_{2}a_{2},…,x_{k}a_{k}}$的个数。 该问题等价于求$x_{1}+x_{2}+…x_{k}=r$的非负整数解的个数。 上面的问题可以转化为求多重集$T={r\cdot 1,(k-1)\cdot \ast}$ 的全排列的个数。给定T的一个排列$$11…1 \ast 11…1 \ast 11…1 \ast … \ast11…1$$$x_{1}$ 代表第一个 $\ast$ 之前1的数目，$x_{2}$代表第一个$\ast$与第二个$\ast$ 之间1的数目，一次类推，由上面可得S的r-组合个数。 不相邻组合 给定一个序列${1,2,3,…,n}$， 从中取r个元素做组合，组合中不得出现$i,i+1$两个相邻的数，其个数为$$\binom{n-r-1}{r}=\binom{n-r-1}{n-1}$$]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 高级用法]]></title>
    <url>%2F2017%2F08%2F31%2Fgit-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[rebase变基 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作 如上图所示，C4所在分支为experiment，执行 1234git checkout experiment #1git rebase master #2 1,2可简写为 git rebase [basebranch] [topicbranch]git checkout master #3git merge experiment #4 &emsp;&emsp;变基原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。&emsp;&emsp;3,4两条命令回到master分支，进行Fast-Forward。此时最终结果与merge中快照相同，最终结果没有区别。尽管开发过程是并行的，但其历史记录是串行的。这样可以在向远程分支推送时保持提交历史的整洁。&emsp;&emsp;无论是通过变基还是三方合并，最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 git rebase --onto master server client 意为： 取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍 交互式暂存 git add -i或git add -interactive 开启交互式终端模式，具体操作参考提示。 在交互式模式中输入5可以进入暂存补丁模式，可以挑选并将文件的一部分修改暂存。其中输入?可以显示所有可以用的命令列表。 git add -p或git add -patch 也可以用于做部分文件暂存。 储藏与清理 git stash 用于在不做一次提交的情况下保存状态。 储藏会处理工作目录的脏的状态 - 即，修改的跟踪文件与暂存改动 - 然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。 git stash list 显示存储在栈上的储藏列表。 git stash apply 应用最近的一个储藏，如git stash apply stash@{1} 则会应用到指定储藏。 git stash pop 应用储藏并从栈中丢弃。等于git stash apply+git stash drop，其中，drop命令也可以指定要丢弃的储藏。 git stash --keep-index用于告知git不储藏已经暂存的部分。 git stash -u或git stash --include-untracked可以储藏任何创建的未跟踪文件。 git stash --patch可以交互式提示将哪些改动储藏，哪些改动保存在工作目录。 采用git stash branch [testchanges] 检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏,这是在新分支轻松恢复储藏工作并继续工作的一个很不错的途径。 git clean 默认从工作目录中移除没有忽略的未跟踪文件，git clean -f -d 移除工作目录中所有未追踪的文件以及空的子目录。 -f意味着强制移除。git clean -d -n做一次演习然后告诉你 将要移除什么。-x除未跟踪文件外，移除.gitignore中的文件。建议在git clean时先用-n参数查看，另一种方式是用-i来交互式运行 git stash --all可以将所有文件移除并放入栈中。 重置 Git作为内容管理器，其框架为三棵不同的树（文件集合）。 |树 | 用途 | |:—————:|:———————————–| |HEAD |上一次提交的快照，下一次提交的父结点| |Index |预期的下一次提交的快照 | |Working Directory|沙盒 | 除工作目录，另两棵树以一种高效但不直观的方式，将内容存储在.git文件夹中。 工作目录会将它们解包为实际的文件以便编辑。git 的具体工作原理图解 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照，然后将 索引 的内容复制到 工作目录 中。 git reset所带的三种参数--soft，--mixed，--hard 1.移动 HEAD 分支的指向 （若指定了 –soft，则到此停止）。 2.使索引看起来像 HEAD （若未指定 –hard，则到此停止）。 3.使工作目录看起来像索引（指定–hard，此操作强制覆盖工作目录 具体见上方链接中图。 git reset [somefile]等于git reset --mixed HEAD [somefile]，本质为将somefile复制到Index。此操作与git add [somefile]正好相反。 git reset [7bit_hash] -- [somefile] 指定从某一个具体的提交拉取文件对应版本到工作目录。此时再运行git add添加该文件，相当于记录了一条将文件恢复到过去版本的更改，而实际上该更改并没有在工作目录中应用。 git reset也接受--patch来一块一块取消暂存内容。 通过git reset --soft HEAD~2来将HEAD分支移动到旧一点的提交上，然后在运行git commit可以实现压缩提交，中间暂时的提交历史就不存在了。 速查列表HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而`‘HEAD’’ 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列 - 如果它标记为 NO，那么运行该命令之前请考虑一下。 HEAD Index Workdir WD Safe? Commit Level reset –soft [commit] REF NO NO YES reset [commit] REF YES NO YES reset –hard [commit] REF YES YES NO checkout [commit] HEAD YES YES YES File Level reset (commit) [file] NO YES NO YES checkout (commit) [file] NO YES YES NO 参考文献[1]Chacon S, Straub B. Pro git[M]. Apress, 2014.]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git and branch 二]]></title>
    <url>%2F2017%2F08%2F30%2Fgit-and-branch-2%2F</url>
    <content type="text"><![CDATA[分支的新建与合并 git checkout -b [branchname] 新建一分支的同时切换到那个分支。 git merge [branchname] 合并分支，当HEAD在要合并的分支上游的分支时，Git 会采用Fast-forward，来简单的将指针向前推进，这种情况下没有需要解决的分歧，叫做”快进” 。 git branch -d [branchname] 可以将不需要的分支删除，如合并后不再需要的分支。 当要合并的分支同当前分支从一个更早的地缝分叉时，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并，如图所示。 Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。使用git status 可以在合并冲突后的任意时刻查看因包含合并冲突而未合并的文件。Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，如下所示： 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 上半部分区段（======= 的上半部分）即HEAD 所指示的分支（也就是master 分支所在的位置，因为在运行 merge 命令的时候已经checkout到了这个分支），而 iss53 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，可以选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。最后将&lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= , 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行完全删除。对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。 分支管理 git branch 返回当前所有分支别表，加入-v参数会显示详细信息，--merged和--no-merged可以过滤已经合并或还未合并的分支。 远程分支 远程跟踪分支时远程分支状态的引用，其以(remote)/(branch)形式命名。clone时，本地会同时存在一个远程分支和一个本地分支。如下图： 在本地做了的改动提交后，本地的master分支会前进，如果不与origin服务器链接，origin/master指针不会发生移动。 git fetch origin运行该命令后，会从origin服务器抓取本地没有的数据，移动origin/master指针到新的位置如图。 本地分支不会自动与远程仓库同步，必须显式的推送，git push (remote) (branch)，这条命令相当于一个git push (remote) (localbranchname):(remotebranchname)的简化，将本地的分支推送为远程仓库同名的分支。可以使用后面复杂的命令来将本地分支推送到一个远程仓库的不同命名的分支。 在一段时间的工作后，执行git fetch origin抓取，在本地生成origin/somebranch的远程分支，这时本地不会有一个新的somebranch分支，只有一个不可修改的origin/somebranch指针。可以运行git merge origin/somebranch将远程分支的工作合并到当前分支，也可以通过git merge origin/somebranch在自己的somebranch分支上工作。 从一个远程分支checkout的本地分支会自动创建为跟踪分支，其执行git pull时会自动识别到哪个远程服务器抓取，合并。克隆仓库时创建的master分支会自动成为origin/master的跟踪分支。 git checkout -b [branch] [remotename]/[branch] 可以手动创建分支跟踪，该命令简写为git checkout --track [remotename]/[branch]，意为git checkout -b somebranch [remotename]/somebranch为同一branch名。 git branch -u [remote]/[branch] 可以修改所跟踪的上游分支。跟踪分支在设置好后，可以简写，[remotename]/[branch]等价为@{u}。 git branch -vv 可以查看每一个分支与正在跟踪分支的详细情况，要想查看最新的状态，可以在执行该命令前执行git fetch -all。 git pull相当于git fetch+git merge。 git push [remotename] --delete [branch] 可以从远程仓库删除某分支。 参考文献[1]Chacon S, Straub B. Pro git[M]. Apress, 2014.]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git and branch]]></title>
    <url>%2F2017%2F08%2F29%2Fgit-and-branch%2F</url>
    <content type="text"><![CDATA[brach 基础 Git所提交的对象(commit object)，包含一个指向暂存内容快照的指针，还有作者的姓名和邮箱，提交时输入的信息以及指向它父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，多个分支合并产生的提交对象有多个父对象。当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。修改后再次提交： Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。 分支创建 git branch [branchname] 创建一个新的分支，这会在当前所提交对象上创建一个指针。Git通过HEAD的特殊指针， 来指示它当前在哪一个分支。上面命令执行后，HEAD指针所在位置如图： git log --oneline --decorate 可以快捷查看各个分支当前所指对象。 分支切换 git checkout [branchname] 用来切换到一个已经存在的分支。（将HEAD指向另一个分支） 在执行commit后，HEAD所在分支会向前移动。 当执行git checkout master后，HEAD会指回master分支，并且工作目录会恢复成master分支所指向的快照内容。 两次改动针对不同的分支时，项目会产生分叉，可以在不同的分支间不断来回切换和工作，并在适当时合并。 git log --oneline --decorate --graph --all 可以显示提交历史，各分支的指向以及项目的分支分叉情况。 参考文献[1]Chacon S, Straub B. Pro git[M]. Apress, 2014.]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git and based]]></title>
    <url>%2F2017%2F08%2F28%2Fgit-and-based%2F</url>
    <content type="text"><![CDATA[Git Before git 有三种状态，分别为已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 初次运行git前配置用户信息。每一个git提交都会使用。12$ git config --global user.name "John Doe"$ git config --global user.email johndoe@example.com &emsp;&emsp;Tips:–global 选项写入~/.gitconfig 或 ~/.config/git/config 文件，如不加–global，在git仓库中运行时，会写入仓库中的config文件，即为.git/config，后面的内容会覆盖前面的内容。&emsp;&emsp;git config --list会检查git配置信息 git帮助命令 $ git &lt;verb&gt; --help git 基础记录每次更新 git clone [url] [folderName] 可以将克隆仓库文件夹重新命名 git status 查看当前的文件状态gti status -s 可以查看文件状态的简报，其中： 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。如下例：123456$ git status -s M README MM Rakefile A lib/git.rb M lib/simplegit.rb ?? LICENSE.txt .gitignore中，匹配模式可以以（/）开头,仅匹配当前目录下文件而非子目录下文件，可以以（/）结尾指定目录，要忽略指定模式以外的文件或目录，可以在模式前加上（!）取反。github包含常用的各种项目的.gitignore git diff 只显示尚未暂存的改动git diff --staged 查看已暂存的将要添加到下次提交里的内容 git commit -m &quot;something&quot; -m 选项，表示将提交信息与命令放在同一行git commit -a -m &quot;something&quot; -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 git rm --cached [filename or glob pattern] 将文件从暂存区移除，适合于忘记添加.gitignore的情况，此外，这里glob模式中的*号需要\注释，以正常执行命令。 git mv [oldfilename] [newfilename] 一气呵成的进行文件改名，和提交暂存。 查看提交历史 git log 不提交任何参数，返回按提交时间列出所有更新。常用选项： -p显示每次提交内容差异 --stat显示每次提交的简略统计信息 --pretty=format:&quot;[format]&quot; 指定不同默认格式展示提交历史，用于后期提取分析。link --pretty=oneline 将每个提交放在一行，它与--format都能配合--graph使用，来展示分支合并历史。 git log 可以通过选项限制输出长度。--sine=[time]可以显示指定时间之后的提交，--until=[time] 可以显示指定时间之前的提交，其中time的格式可以为，2.weeks或&quot;2017-08-29&quot;。 git log 可以给出若干搜索条件，--author选项用来指定作者，--grep指定提交说明中关键字。 搜索条件-Sfunction_name 列出添加或移除了某些字符串的提交。 如果需要限定路径，可在git log最后加上路径，在前面要用--与其余的选项隔开。 git的撤销操作 在提交后发现提交信息写错或漏掉文件，可使用git commit --amend git reset HEAD &lt;file&gt; 可以用于取消已放入暂存区的某文件 git checkout -- &lt;file&gt; 可以用于撤销修改，用之前的版本替换该文件。该命令为危险命令，会使得任何更改消失 远程仓库 git remote -v可以获得需要读写远程仓库使用的Git保存的简写与其对应URL。 添加远程仓库，使用git remote add &lt;shortname&gt; &lt;url&gt;，在提供URL同时制定一个可以轻松引用的简写。 git fetch [remote-name] 从远程仓库中获取数据到本地仓库，该操作并不会自动合并或者修改当前工作git pull会从最初克隆服务器上抓取数据并自动尝试合并到当前所在分支。&emsp;&emsp;Tips:如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 推送到远程仓库，使用git push [remote-name] [branch-name]，如将master分支推送到origin服务器，执行$ git push origin master 。 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 git remote show [remote-name] 可以列出一个远程仓库的详细信息。 重命名远程仓库git remote rename [originalname] [newname]该方式也会修改远程分支名移除一个远程仓库 git remote rm [remote-name] 打标签Git 可以给历史中的某一个提交打上标签，以示重要。 创建标签 附注标签 git tag -a v1.4 -m &quot;something&quot;， 其中-a表示该标签为附注标签，-m 表示行内指定信息。使用git show v1.4 可以看到标签信息与对应提交信息。 轻量标签 git tag v1.4-lw 对过去提交打标签首先使用git log [someparam] 获得提交历史，找到需要打标签的过去的提交项目，将其7位hash值（短hash值）作为参数传入。 例：git tag -a v1.2 9fceb02 标签不会随git push传送到远程仓库， 需要使用git push origin [tagname]， 来显式的推送标签。使用git push origin --tags 可以一次性将不在远程仓库服务器上所有标签全部传送。 git别名 别名使用方法如例：git config --global alias.st status， 设置完成后，使用git st就等价于使用git status 。 常用别名 $ git config --global alias.unstage &#39;reset HEAD --&#39; 可以用git unstage fileA 来代替繁琐的 git reset HEAD -- fileA 参考文献[1]Chacon S, Straub B. Pro git[M]. Apress, 2014.]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook笔记]]></title>
    <url>%2F2017%2F08%2F28%2FJupyter-Notebook%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[notebook 基本操作 在shell下键入jupyter notebook，启动notebook本地server。&emsp;&emsp;Tips:shell 的当前路径会作为notebook中python语句的执行路径，建议选在自己的workspace，以缩短相对路径。 ctrl+enter run cell 执行当前格。shift+enter run cell,select next 执行当前格并选中下一格。alt+enter run cell, insert below 执行当前格，并在下插入一格。 在格首键入&emsp;!，后面跟随的语句会被解释为shell code。&emsp;code in cell begin with exclamation mark with interpret as shell code. magic commads：&emsp;&emsp;%lsmagic 列出所有的magic commads&emsp;&emsp;%pwd 返回当前的绝对路径&emsp;&emsp;%qtconsole 调出qt版ipython&emsp;&emsp;%ls 列出当前目录下文件&emsp;&emsp;%matplotlib inline 将matplotlib所绘制的图显示在notebook内&emsp;&emsp;%config InlineBackend.figure_format = &#39;svg&#39; 将输出图片格式变为svg，也可换为jpeg或png&emsp;&emsp;%%HTML 表明该格中为html代码，可直接执行。类似还有%%javascript&emsp;&emsp;%%timeit 将一段py代码执行timeit 在cell中，可以直接显示pandas的DataFrame以表格形式。 在File->Download as-> Markdown(.md) 可以将svg文件另存为。&emsp;&emsp;其他内容详见ipython 学习。]]></content>
      <tags>
        <tag>python</tag>
        <tag>ipython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客多机更新实战]]></title>
    <url>%2F2017%2F08%2F27%2Fhexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E6%9C%BA%E6%9B%B4%E6%96%B0%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[将A计算机上的博客部署到git一、 注册oschina账号，在其gitee上建立一个新的私有repo。二、 在A计算机，已经部署好的hexo博客根目录下删除原有的.git文件夹，包括子目录下的.git文件夹也一并删除。三、 修改hexo博客根目录下本已存在的.gitignore文件，在其中加入如下内容。123/.deploy_git/public /_config.yml &emsp;&emsp;其中_config.yml可以加入也可以不加入，此处考虑安全原因，建议使用其他方法将该文件同步。四、 在git bash中输入命令12345git initgit remote add origin &lt;server&gt;git add .git commit -m "something"git push -u origin master &emsp;&emsp;至此A计算机的操作结束。 在B计算机上做准备一、在B计算机上将node.js，git和hexo安装完毕。&emsp;&emsp;Tips:此处应使用系统自带的shell而不是git bash,git bash会在hexo的执行路径添加上当前盘符，导致error 471，找不到nodejs的库。检测hexo是否安装成功请使用hexo -v，出现版本号说明hexo安装成功。二、 在自己想要建立blog的地方打开shell，键入以下命令。123hexo init &lt;yourfoldername&gt;cd &lt;yourfoldername&gt;npm install 三、 在博客根目录下，安装你在A计算机上安装过的hexo插件，本人只安装了一个插件,因此只有一条命令。1234npm install hexo-deployer-git --savenpm install hexo-generator-searchdb --savenpm install hexo-generator-tag --savenpm install hexo-generator-sitemap --save 四、 测试是否正常运行。根目录下键入hexo g，没有出现异常说明安装成功。 将私有repo上的内容同步到B计算机一、在博客更目录下执行以下代码1234git initgit remote add origin &lt;server&gt;git fetch --allgit reset --hard origin/master 二、 将A计算机的站点配置文件_config.yml复制到B计算机博客根目录下，覆盖已经存在的文件。三、 至此两台计算机都完成了hexo部署工作 每次写博客时需要执行的命令一、 写博客前，需要完成以下命令12git pull &lt;server&gt; masterhexo n "filename" 二、 在你自己喜欢的markdown编辑器中编辑博客内容，并保存。三、 执行下列命令123456hexo cleanhexo ghexo dgit add .git commit -m "something"git push -u origin master #以后可以直接用git push]]></content>
      <tags>
        <tag>git</tag>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown与sublime text 3]]></title>
    <url>%2F2017%2F08%2F27%2Fmarkdown%E4%B8%8Esublime-text-3%2F</url>
    <content type="text"><![CDATA[sublime markdown editing 快捷键alt+b 加粗alt+i _斜体_再按一次取消ctrl+1 一号标题ctrl+2 二号标题…ctrl+6 六号标题win+shift+k 插入图片win+shift+v 插入链接 markdown 简明注解wiki链接]]></content>
      <tags>
        <tag>markdown</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于拉格朗日插值法]]></title>
    <url>%2F2017%2F08%2F21%2F%E5%85%B3%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[拉格朗日插值法的证明 wiki]]></content>
  </entry>
</search>
