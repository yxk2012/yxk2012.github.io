<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git and branch 二]]></title>
    <url>%2F2017%2F08%2F30%2Fgit-and-branch-2%2F</url>
    <content type="text"><![CDATA[分支的新建与合并 git checkout -b [branchname] 新建一分支的同时切换到那个分支。 git merge [branchname] 合并分支，当HEAD在要合并的分支上游的分支时，Git 会采用Fast-forward，来简单的将指针向前推进，这种情况下没有需要解决的分歧，叫做”快进” 。 git branch -d [branchname] 可以将不需要的分支删除，如合并后不再需要的分支。 当要合并的分支同当前分支从一个更早的地缝分叉时，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并，如图所示。 Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。使用git status 可以在合并冲突后的任意时刻查看因包含合并冲突而未合并的文件。Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，如下所示： 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 上半部分区段（======= 的上半部分）即HEAD 所指示的分支（也就是master 分支所在的位置，因为在运行 merge 命令的时候已经checkout到了这个分支），而 iss53 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，可以选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。最后将&lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= , 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行完全删除。对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。 分支管理 git branch 返回当前所有分支别表，加入-v参数会显示详细信息，--merged和--no-merged可以过滤已经合并或还未合并的分支。 远程分支 远程跟踪分支时远程分支状态的引用，其以(remote)/(branch)形式命名。clone时，本地会同时存在一个远程分支和一个本地分支。如下图： 在本地做了的改动提交后，本地的master分支会前进，如果不与origin服务器链接，origin/master指针不会发生移动。 git fetch origin运行该命令后，会从origin服务器抓取本地没有的数据，移动origin/master指针到新的位置如图。 本地分支不会自动与远程仓库同步，必须显式的推送，git push (remote) (branch)，这条命令相当于一个git push (remote) (localbranchname):(remotebranchname)的简化，将本地的分支推送为远程仓库同名的分支。可以使用后面复杂的命令来将本地分支推送到一个远程仓库的不同命名的分支。 在一段时间的工作后，执行git fetch origin抓取，在本地生成origin/somebranch的远程分支，这时本地不会有一个新的somebranch分支，只有一个不可修改的origin/somebranch指针。可以运行git merge origin/somebranch将远程分支的工作合并到当前分支，也可以通过git merge origin/somebranch在自己的somebranch分支上工作。 从一个远程分支checkout的本地分支会自动创建为跟踪分支，其执行git pull时会自动识别到哪个远程服务器抓取，合并。克隆仓库时创建的master分支会自动成为origin/master的跟踪分支。 git checkout -b [branch] [remotename]/[branch] 可以手动创建分支跟踪，该命令简写为git checkout --track [remotename]/[branch]，意为git checkout -b somebranch [remotename]/somebranch为同一branch名。 git branch -u [remote]/[branch] 可以修改所跟踪的上游分支。跟踪分支在设置好后，可以简写，[remotename]/[branch]等价为@{u}。 git branch -vv 可以查看每一个分支与正在跟踪分支的详细情况，要想查看最新的状态，可以在执行该命令前执行git fetch -all。 git pull相当于git fetch+git merge。 git push [remotename] --delete [branch] 可以从远程仓库删除某分支。 参考文献[1]Chacon S, Straub B. Pro git[M]. Apress, 2014.]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git and branch]]></title>
    <url>%2F2017%2F08%2F29%2Fgit-and-branch%2F</url>
    <content type="text"><![CDATA[brach 基础 Git所提交的对象(commit object)，包含一个指向暂存内容快照的指针，还有作者的姓名和邮箱，提交时输入的信息以及指向它父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，多个分支合并产生的提交对象有多个父对象。当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。修改后再次提交： Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。 分支创建 git branch [branchname] 创建一个新的分支，这会在当前所提交对象上创建一个指针。Git通过HEAD的特殊指针， 来指示它当前在哪一个分支。上面命令执行后，HEAD指针所在位置如图： git log --oneline --decorate 可以快捷查看各个分支当前所指对象。 分支切换 git checkout [branchname] 用来切换到一个已经存在的分支。（将HEAD指向另一个分支） 在执行commit后，HEAD所在分支会向前移动。 当执行git checkout master后，HEAD会指回master分支，并且工作目录会恢复成master分支所指向的快照内容。 两次改动针对不同的分支时，项目会产生分叉，可以在不同的分支间不断来回切换和工作，并在适当时合并。 git log --oneline --decorate --graph --all 可以显示提交历史，各分支的指向以及项目的分支分叉情况。 参考文献[1]Chacon S, Straub B. Pro git[M]. Apress, 2014.]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git and based]]></title>
    <url>%2F2017%2F08%2F28%2Fgit-and-based%2F</url>
    <content type="text"><![CDATA[Git Before git 有三种状态，分别为已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 初次运行git前配置用户信息。每一个git提交都会使用。12$ git config --global user.name "John Doe"$ git config --global user.email johndoe@example.com &emsp;&emsp;Tips:–global 选项写入~/.gitconfig 或 ~/.config/git/config 文件，如不加–global，在git仓库中运行时，会写入仓库中的config文件，即为.git/config，后面的内容会覆盖前面的内容。&emsp;&emsp;git config --list会检查git配置信息 git帮助命令 $ git &lt;verb&gt; --help git 基础记录每次更新 git clone [url] [folderName] 可以将克隆仓库文件夹重新命名 git status 查看当前的文件状态gti status -s 可以查看文件状态的简报，其中： 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。如下例：123456$ git status -s M README MM Rakefile A lib/git.rb M lib/simplegit.rb ?? LICENSE.txt .gitignore中，匹配模式可以以（/）开头,仅匹配当前目录下文件而非子目录下文件，可以以（/）结尾指定目录，要忽略指定模式以外的文件或目录，可以在模式前加上（!）取反。github包含常用的各种项目的.gitignore git diff 只显示尚未暂存的改动git diff --staged 查看已暂存的将要添加到下次提交里的内容 git commit -m &quot;something&quot; -m 选项，表示将提交信息与命令放在同一行git commit -a -m &quot;something&quot; -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 git rm --cached [filename or glob pattern] 将文件从暂存区移除，适合于忘记添加.gitignore的情况，此外，这里glob模式中的*号需要\注释，以正常执行命令。 git mv [oldfilename] [newfilename] 一气呵成的进行文件改名，和提交暂存。 查看提交历史 git log 不提交任何参数，返回按提交时间列出所有更新。常用选项： -p显示每次提交内容差异 --stat显示每次提交的简略统计信息 --pretty=format:&quot;[format]&quot; 指定不同默认格式展示提交历史，用于后期提取分析。link --pretty=oneline 将每个提交放在一行，它与--format都能配合--graph使用，来展示分支合并历史。 git log 可以通过选项限制输出长度。--sine=[time]可以显示指定时间之后的提交，--until=[time] 可以显示指定时间之前的提交，其中time的格式可以为，2.weeks或&quot;2017-08-29&quot;。 git log 可以给出若干搜索条件，--author选项用来指定作者，--grep指定提交说明中关键字。 搜索条件-Sfunction_name 列出添加或移除了某些字符串的提交。 如果需要限定路径，可在git log最后加上路径，在前面要用--与其余的选项隔开。 git的撤销操作 在提交后发现提交信息写错或漏掉文件，可使用git commit --amend git reset HEAD &lt;file&gt; 可以用于取消已放入暂存区的某文件 git checkout -- &lt;file&gt; 可以用于撤销修改，用之前的版本替换该文件。该命令为危险命令，会使得任何更改消失 远程仓库 git remote -v可以获得需要读写远程仓库使用的Git保存的简写与其对应URL。 添加远程仓库，使用git remote add &lt;shortname&gt; &lt;url&gt;，在提供URL同时制定一个可以轻松引用的简写。 git fetch [remote-name] 从远程仓库中获取数据到本地仓库，该操作并不会自动合并或者修改当前工作git pull会从最初克隆服务器上抓取数据并自动尝试合并到当前所在分支。&emsp;&emsp;Tips:如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 推送到远程仓库，使用git push [remote-name] [branch-name]，如将master分支推送到origin服务器，执行$ git push origin master 。 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 git remote show [remote-name] 可以列出一个远程仓库的详细信息。 重命名远程仓库git remote rename [originalname] [newname]该方式也会修改远程分支名移除一个远程仓库 git remote rm [remote-name] 打标签Git 可以给历史中的某一个提交打上标签，以示重要。 创建标签 附注标签 git tag -a v1.4 -m &quot;something&quot;， 其中-a表示该标签为附注标签，-m 表示行内指定信息。使用git show v1.4 可以看到标签信息与对应提交信息。 轻量标签 git tag v1.4-lw 对过去提交打标签首先使用git log [someparam] 获得提交历史，找到需要打标签的过去的提交项目，将其7位hash值（短hash值）作为参数传入。 例：git tag -a v1.2 9fceb02 标签不会随git push传送到远程仓库， 需要使用git push origin [tagname]， 来显式的推送标签。使用git push origin --tags 可以一次性将不在远程仓库服务器上所有标签全部传送。 git别名 别名使用方法如例：git config --global alias.st status， 设置完成后，使用git st就等价于使用git status 。 常用别名 $ git config --global alias.unstage &#39;reset HEAD --&#39; 可以用git unstage fileA 来代替繁琐的 git reset HEAD -- fileA 参考文献[1]Chacon S, Straub B. Pro git[M]. Apress, 2014.]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook笔记]]></title>
    <url>%2F2017%2F08%2F28%2FJupyter-Notebook%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[notebook 基本操作 在shell下键入jupyter notebook，启动notebook本地server。&emsp;&emsp;Tips:shell 的当前路径会作为notebook中python语句的执行路径，建议选在自己的workspace，以缩短相对路径。 ctrl+enter run cell 执行当前格。shift+enter run cell,select next 执行当前格并选中下一格。alt+enter run cell, insert below 执行当前格，并在下插入一格。 在格首键入&emsp;!，后面跟随的语句会被解释为shell code。&emsp;code in cell begin with exclamation mark with interpret as shell code. magic commads：&emsp;&emsp;%lsmagic 列出所有的magic commads&emsp;&emsp;%pwd 返回当前的绝对路径&emsp;&emsp;%qtconsole 调出qt版ipython&emsp;&emsp;%ls 列出当前目录下文件&emsp;&emsp;%matplotlib inline 将matplotlib所绘制的图显示在notebook内&emsp;&emsp;%config InlineBackend.figure_format = &#39;svg&#39; 将输出图片格式变为svg，也可换为jpeg或png&emsp;&emsp;%%HTML 表明该格中为html代码，可直接执行。类似还有%%javascript&emsp;&emsp;%%timeit 将一段py代码执行timeit 在cell中，可以直接显示pandas的DataFrame以表格形式。 在File->Download as-> Markdown(.md) 可以将svg文件另存为。&emsp;&emsp;其他内容详见ipython 学习。]]></content>
      <tags>
        <tag>python</tag>
        <tag>ipython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客多机更新实战]]></title>
    <url>%2F2017%2F08%2F27%2Fhexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E6%9C%BA%E6%9B%B4%E6%96%B0%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[将A计算机上的博客部署到git一、 注册oschina账号，在其gitee上建立一个新的私有repo。二、 在A计算机，已经部署好的hexo博客根目录下删除原有的.git文件夹，包括子目录下的.git文件夹也一并删除。三、 修改hexo博客根目录下本已存在的.gitignore文件，在其中加入如下内容。123/.deploy_git/public /_config.yml &emsp;&emsp;其中_config.yml可以加入也可以不加入，此处考虑安全原因，建议使用其他方法将该文件同步。四、 在git bash中输入命令12345git initgit remote add origin &lt;server&gt;git add .git commit -m "something"git push -u origin master &emsp;&emsp;至此A计算机的操作结束。 在B计算机上做准备一、在B计算机上将node.js，git和hexo安装完毕。&emsp;&emsp;Tips:此处应使用系统自带的shell而不是git bash,git bash会在hexo的执行路径添加上当前盘符，导致error 471，找不到nodejs的库。检测hexo是否安装成功请使用hexo -v，出现版本号说明hexo安装成功。二、 在自己想要建立blog的地方打开shell，键入以下命令。123hexo init &lt;yourfoldername&gt;cd &lt;yourfoldername&gt;npm install 三、 在博客根目录下，安装你在A计算机上安装过的hexo插件，本人只安装了一个插件,因此只有一条命令。1234npm install hexo-deployer-git --savenpm install hexo-generator-searchdb --savenpm install hexo-generator-tag --savenpm install hexo-generator-sitemap --save 四、 测试是否正常运行。根目录下键入hexo g，没有出现异常说明安装成功。 将私有repo上的内容同步到B计算机一、在博客更目录下执行以下代码1234git initgit remote add origin &lt;server&gt;git fetch --allgit reset --hard origin/master 二、 将A计算机的站点配置文件_config.yml复制到B计算机博客根目录下，覆盖已经存在的文件。三、 至此两台计算机都完成了hexo部署工作 每次写博客时需要执行的命令一、 写博客前，需要完成以下命令12git pull &lt;server&gt; masterhexo n "filename" 二、 在你自己喜欢的markdown编辑器中编辑博客内容，并保存。三、 执行下列命令123456hexo cleanhexo ghexo dgit add .git commit -m "something"git push -u origin master #以后可以直接用git push]]></content>
      <tags>
        <tag>git</tag>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown与sublime text 3]]></title>
    <url>%2F2017%2F08%2F27%2Fmarkdown%E4%B8%8Esublime-text-3%2F</url>
    <content type="text"><![CDATA[sublime markdown editing 快捷键alt+b 加粗alt+i 斜体再按一次取消ctrl+1 一号标题ctrl+2 二号标题…ctrl+6 六号标题win+shift+k 插入图片win+shift+v 插入链接 markdown 简明注解wiki链接]]></content>
      <tags>
        <tag>markdown</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于拉格朗日插值法]]></title>
    <url>%2F2017%2F08%2F21%2F%E5%85%B3%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[拉格朗日插值法的证明 wiki]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
